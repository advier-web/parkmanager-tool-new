#!/usr/bin/env ts-node
/**
 * Script om types te genereren vanuit het Contentful content model
 * 
 * Gebruik:
 * - Installeer eerst de dependencies: npm install -D contentful-management ts-node
 * - Voeg CONTENTFUL_MANAGEMENT_TOKEN toe aan je .env.local
 * - Voer het script uit: npx ts-node scripts/generate-contentful-types.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { createClient } from 'contentful-management';

// Environment variables
const SPACE_ID = process.env.NEXT_PUBLIC_CONTENTFUL_SPACE_ID || '';
const ENVIRONMENT = process.env.NEXT_PUBLIC_CONTENTFUL_ENVIRONMENT || 'master';
const MANAGEMENT_TOKEN = process.env.CONTENTFUL_MANAGEMENT_TOKEN || '';

// Controleer of de environment variables zijn ingesteld
if (!SPACE_ID || !MANAGEMENT_TOKEN) {
  console.error('Error: NEXT_PUBLIC_CONTENTFUL_SPACE_ID en CONTENTFUL_MANAGEMENT_TOKEN moeten worden ingesteld');
  process.exit(1);
}

// Pad voor de gegenereerde types
const OUTPUT_FILE = path.resolve(__dirname, '../src/types/contentful-types.generated.ts');

// Maak een Contentful Management client
const client = createClient({
  accessToken: MANAGEMENT_TOKEN,
});

/**
 * Zet Contentful types om naar TypeScript types
 */
function contentfulTypeToTs(type: string, required: boolean): string {
  // Basic type mapping
  const typeMap: Record<string, string> = {
    Symbol: 'string',
    Text: 'string',
    Integer: 'number',
    Number: 'number',
    Date: 'string',
    Boolean: 'boolean',
    Object: 'Record<string, any>',
    Location: '{ lat: number; lon: number }',
  };

  let tsType = typeMap[type] || 'any';
  
  // Voeg optionele type marker toe indien nodig
  if (!required) {
    tsType += ' | undefined';
  }

  return tsType;
}

/**
 * Genereer TypeScript interface voor een content type
 */
function generateContentTypeInterface(contentType: any): string {
  const name = contentType.sys.id;
  const displayName = contentType.name;
  const fields = contentType.fields || [];

  // Begin met de interface voor de velden
  let fieldsInterface = `export interface I${name}Fields {\n`;

  // Voeg elk veld toe aan de interface
  fields.forEach((field: any) => {
    const fieldName = field.id;
    const isRequired = field.required;
    const fieldType = field.type;

    // Add description as JSDoc comment if available
    if (field.description) {
      fieldsInterface += `  /** ${field.description} */\n`;
    }

    // Handle different field types
    if (fieldType === 'Array') {
      const itemType = field.items.type;
      if (itemType === 'Symbol' || itemType === 'Text') {
        fieldsInterface += `  ${fieldName}${isRequired ? '' : '?'}: string[];\n`;
      } else if (itemType === 'Link') {
        const linkType = field.items.linkType;
        if (linkType === 'Entry') {
          fieldsInterface += `  ${fieldName}${isRequired ? '' : '?'}: { sys: { id: string } }[];\n`;
        } else if (linkType === 'Asset') {
          fieldsInterface += `  ${fieldName}${isRequired ? '' : '?'}: { sys: { id: string } }[];\n`;
        }
      } else {
        fieldsInterface += `  ${fieldName}${isRequired ? '' : '?'}: any[];\n`;
      }
    } else if (fieldType === 'Link') {
      const linkType = field.linkType;
      if (linkType === 'Entry') {
        fieldsInterface += `  ${fieldName}${isRequired ? '' : '?'}: { sys: { id: string } };\n`;
      } else if (linkType === 'Asset') {
        fieldsInterface += `  ${fieldName}${isRequired ? '' : '?'}: { sys: { id: string } };\n`;
      }
    } else {
      fieldsInterface += `  ${fieldName}${isRequired ? '' : '?'}: ${contentfulTypeToTs(fieldType, isRequired)};\n`;
    }
  });

  fieldsInterface += '}\n\n';

  // Voeg de entry interface toe
  const entryInterface = `export interface I${name} extends EntrySkeletonType<I${name}Fields> {\n  contentTypeId: '${name}';\n}\n\n`;

  return fieldsInterface + entryInterface;
}

/**
 * Generate the types file header
 */
function generateTypesFileHeader(): string {
  return `/**
 * THIS FILE IS AUTO-GENERATED FROM CONTENTFUL
 * Do not edit this file directly
 * Generated on: ${new Date().toISOString()}
 */

export interface EntryFields {
  [key: string]: any;
}

export interface EntrySkeletonType<T extends EntryFields = EntryFields> {
  sys: {
    id: string;
    createdAt: string;
    updatedAt: string;
    contentTypeId: string;
  };
  fields: T;
}

`;
}

/**
 * Main function to generate types
 */
async function generateTypes() {
  try {
    console.log('Contentful Types Generator: Starting...');
    
    // Haal de space en environment op
    const space = await client.getSpace(SPACE_ID);
    const environment = await space.getEnvironment(ENVIRONMENT);
    
    console.log(`Generating types for space: ${SPACE_ID}, environment: ${ENVIRONMENT}`);
    
    // Haal alle content types op
    const contentTypes = await environment.getContentTypes({ limit: 1000 });
    
    // Genereer de types file inhoud
    let typesFileContent = generateTypesFileHeader();
    
    // Voeg interfaces toe voor elk content type
    for (const contentType of contentTypes.items) {
      typesFileContent += generateContentTypeInterface(contentType);
    }
    
    // Zorg ervoor dat de output directory bestaat
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Schrijf de gegenereerde content naar het output bestand
    fs.writeFileSync(OUTPUT_FILE, typesFileContent);
    
    console.log(`âœ… Generated Contentful types at: ${OUTPUT_FILE}`);
  } catch (error) {
    console.error('Error generating Contentful types:', error);
    process.exit(1);
  }
}

// Run the type generation
generateTypes(); 